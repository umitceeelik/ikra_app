import 'package:hive_flutter/hive_flutter.dart';
import '../../domain/entities/ayah.dart';
import '../../domain/entities/surah.dart';
import '../../domain/entities/reading_progress.dart';
import '../../core/hive_boxes.dart';
import '../models/ayah.dart';
import '../models/surah.dart';
import '../models/reading_progress.dart';

/// Local data source powered by Hive.
/// Responsible for: initializing Hive, opening boxes, and simple reads/writes.
class QuranLocalDataSource {
  /// Call on app startup: initializes Hive, registers adapters, opens boxes.
  Future<void> init() async {
    await Hive.initFlutter();                    // Prepares platform paths

    // Register adapters generated by build_runner
    Hive
      ..registerAdapter(SurahHiveAdapter())
      ..registerAdapter(AyahHiveAdapter())
      ..registerAdapter(ReadingProgressHiveAdapter());

    // Open typed boxes so we get type-safe reads/writes
    await Hive.openBox<SurahHive>(HiveBoxes.surahs);
    await Hive.openBox<AyahHive>(HiveBoxes.ayahs);
    await Hive.openBox<ReadingProgressHive>(HiveBoxes.progress);
  }

  /// Whether local storage is empty (used to decide if seeding is needed).
  bool isEmpty() {
    final s = Hive.box<SurahHive>(HiveBoxes.surahs);
    final a = Hive.box<AyahHive>(HiveBoxes.ayahs);
    return s.isEmpty || a.isEmpty;
  }

  /// Bulk write during seeding; clears boxes first to keep data consistent.
  Future<void> writeAll({
    required List<SurahHive> surahs,
    required List<AyahHive> ayahs,
  }) async {
    final s = Hive.box<SurahHive>(HiveBoxes.surahs);
    final a = Hive.box<AyahHive>(HiveBoxes.ayahs);

    await s.clear();
    await a.clear();

    await s.addAll(surahs);
    await a.addAll(ayahs);
  }

  /// Returns a sorted list of Surahs for the UI.
  List<Surah> getSurahList() {
    final s = Hive.box<SurahHive>(HiveBoxes.surahs);
    return s.values
        .map((e) => e.toEntity())
        .toList()
      ..sort((a, b) => a.number.compareTo(b.number));
  }

  /// Returns sorted verses for a given Surah.
  List<Ayah> getAyatBySurah(int surah) {
    final a = Hive.box<AyahHive>(HiveBoxes.ayahs);
    final list = a.values
        .where((x) => x.surah == surah)
        .toList()
      ..sort((p, q) => p.numberInSurah.compareTo(q.numberInSurah));
    return list.map((e) => e.toEntity()).toList();
  }

  /// Get the last reading position, if available.
  ReadingProgress? getReadingProgress() {
    final box = Hive.box<ReadingProgressHive>(HiveBoxes.progress);
    if (box.isEmpty) return null;
    // We store only one record; take the latest (in case of any leftover).
    final latest = box.values.toList()
      ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
    return latest.first.toEntity();
  }

  /// Update the last reading position (upsert).
  Future<void> setReadingProgress(ReadingProgress progress) async {
    final box = Hive.box<ReadingProgressHive>(HiveBoxes.progress);
    // Weâ€™ll keep only a single item for simplicity.
    await box.clear();
    await box.add(ReadingProgressHive.fromEntity(progress));
  }
}
